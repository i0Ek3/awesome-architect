# 网络编程

> Everyting is a fd.

网络编程就是如何在程序中实现两台计算机的通信。

## 基本概念

### 同步 & 异步

同步和异步，都是和消息的通知机制有关系的。同步就是说一个任务的完成需要依赖另一个任务，只有另一个任务完成了，前一个任务才可以完成，这是一种可靠的任务序列。与同步不同，异步讲的是不需要依赖其他任务，即只要自己完成了，整个任务就算完成了，这是一种不可靠的任务序列。

### 消息通知机制

消息通知机制有三种，分别是状态，通知和回调。通常，状态的效率较低，通知的效率很高。

### 阻塞 & 非阻塞

阻塞是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知的状态，不能执行其他任务。

非阻塞是指在不能立刻得到结果之前，该函数不会阻塞当前进程，而会立刻返回。

综上，同步阻塞和同步非阻塞的效率是低下的，而异步非阻塞的效率就很高。

如 socket 中的 recv() 就是阻塞的，如果调用该函数的线程没有数据返回，它就会一直阻塞，后面的代码也就不会执行了。

再如 socket 中的 send() 就是非阻塞的，它只是把代发送的数据复制到 TCP 输出缓冲区中就立刻返回，线程不会阻塞，也就是说 send() 并不关心数据是否发没发出去。

### eventfd & timerfd

eventfd 用来触发事件通知，timerfd 用来触发将来的事件通知。


## I/O 模型

- 阻塞式 I/O：当进程在等待数据时，若该数据一直没有产生，则该进程将一直等待，直到等待的数据产生为止，这个过程中进程的状态就是阻塞的。
- 非阻塞式 I/O：当进程等待内核的数据，而当该数据未到达的时候，进程会不断询问内核，直到内核准备好数据。
- I/O 复用：无需采用多线程监听消息的方式，进程直接监听所有的消息类型。
- 信息驱动式 I/O：用户态进程不再等待内核态的数据准备好，直接可以去做别的事情。
- 异步 I/O：用户态进程告诉内核态所需要的数据后，就去忙自己的事情，直到用户态准备好数据并将数据复制到用户空间上后，用户态进程才开始处理。

## IO 多路复用

多路复用是一种机制，可以用来监听多种描述符，如果其中任意一个描述符处于就绪的状态，就会返回消息给对应的进程通知其采取下一步的操作。

### 优势

- 同时可以监听多个描述符
- 进程中无需开启线程
- 减少系统开销

### 几种方式

- Select：
    - 采用轮询机制，每次检测都会遍历所有的 FD_SET 中的句柄
    - 缺点
        - 单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024
        - 内核/用户空间内存拷贝问题，select 需要复制大量的句柄数据结构，产生巨大的开销
        - select 返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件
        - select 的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行 IO 操作，那么之后每次 select 调用还是会将这些文件描述符通知进程
- Poll：没有最大文件描述符的限制
- Epoll：使用一个描述符来管理多个文件描述符
    - 关键要素
        - mmap：mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换
        - 红黑树：存储 epoll 监听的套接字
        - 链表：
    - 实现机制([具体可参考这里](https://blog.csdn.net/u012398613/article/details/51787548))
        - 调用 epoll_create() 建立一个 epoll 对象，底层会创建一颗红黑树和一个就绪链表
        - 调用 epoll_ctl 向 epoll 对象中添加连接的套接字
        - 调用 epoll_wait 收集发生的事件的连接

## 事件处理模型

主要介绍 Reactor 和 Proactor 两种事件处理模型。

### Reactor

Reactor 模型是同步 I/O 事件处理的一种常见模型。

Reactor 的核心思想：将关注的 I/O 事件注册到多路复用器上，一旦有 I/O 事件触发，将事件分发到事件处理器中，执行就绪 I/O 事件对应的处理函数中。

模型中有三个重要的组件：

- 多路复用器：由操作系统提供接口，Linux提供的I/O复用接口有select、poll、epoll；
- 事件分离器：将多路复用器返回的就绪事件分发到事件处理器中；
- 事件处理器：处理就绪事件处理函数。

Reactor 为反应器，定义一个接口，实现以下功能：

- 供应用程序注册和删除关注的事件句柄；
- 运行事件处理循环；
- 等待的就绪事件触发，分发事件到之前注册的回调函数上处理。

其**工作流程**如下：

- 注册 I/O 就绪事件处理器
- 事件分离器等待 I/O 就绪事件
- I/O 事件触发，激活事件分离器，分离器调度对应的事件处理器
- 事件处理器完成 I/O 操作，处理数据

Reactor 模型的典型应用是 libevent。

### Proactor

与 Reactor 不同的是，Proactor 使用异步 I/O 系统接口将 I/O 操作托管给操作系统，Proactor 模型中分发处理异步 I/O 完成事件，并调用相应的事件处理接口来处理业务逻辑。

Proactor 为主动器，为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑。

其**工作流程**如下：

- 发起 I/O 异步操作，注册 I/O 完成事件处理器;
- 事件分离器等待 I/O 操作完成事件；
- 内核并行执行实际的 I/O 操作，并将结果数据存入用户自定义缓冲区；
- 内核完成I/O操作，通知事件分离器，事件分离器调度对应的事件处理器；
- 事件处理器处理用户自定义缓冲区中的数据。

Proactor 模型的典型应用是 Boost asio。

## Windows 网络编程

### 完成端口

请参考该链接：https://blog.csdn.net/piggyxp/article/details/6922277，讲解的比较繁杂，但是还是不错的。





## Ref

- [https://zhuanlan.zhihu.com/p/40572954](https://zhuanlan.zhihu.com/p/40572954)
- [http://man7.org/linux/man-pages/man2/eventfd.2.html](http://man7.org/linux/man-pages/man2/eventfd.2.html)
- [http://blog.jobbole.com/106933/](http://blog.jobbole.com/106933/)
- [https://segmentfault.com/a/1190000006089519](https://segmentfault.com/a/1190000006089519)
- [https://segmentfault.com/a/1190000016400053](https://segmentfault.com/a/1190000016400053)
- [https://segmentfault.com/a/1190000016359495](https://segmentfault.com/a/1190000016359495)
- [https://blog.csdn.net/shenya1314/article/details/73691088](https://blog.csdn.net/shenya1314/article/details/73691088)
- [https://www.cnblogs.com/lojunren/p/3856290.html](https://www.cnblogs.com/lojunren/p/3856290.html)
- [网络编程学习路线规划](https://www.jianshu.com/p/fa631aecc841)
- [https://tech.youzan.com/yi-bu-wang-luo-mo-xing/](https://tech.youzan.com/yi-bu-wang-luo-mo-xing/)
- [深入理解并发 / 并行，阻塞 / 非阻塞，同步 / 异步](https://juejin.im/entry/58ae4636b123db0052b1caf8)
