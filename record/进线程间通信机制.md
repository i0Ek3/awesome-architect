# 进线程间通信机制

## 进程间通信

### 虚拟文件系统 VFS

就是定义了一个通用文件系统的接口层和适配层，一方面为用户进程提供了一组统一的访问文件，目录和其他对象的统一方法，另一方面又要和不同的底层文件系统进行适配。

#### 主要组成

- 超级块：用于保存一个文件系统的所有元数据，相当于这个文件系统的信息库，为其他的模块提供信息
- 目录项模块：用来管理路径的目录项
- inode 模块：管理一个具体的文件，是文件的唯一标识，一个文件对应一个inode
- 打开文件列表模块：包含所有内核已经打开的文件
- file_operations 模块：该模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如 open、read、write、mmap 等
- address_space 模块：表示一个文件在页缓存中已经缓存了的物理页

### 管道 Pipe

> fork() 是 Unix 系统上创建进程的一种主要方法，且由其创建的进程被称为子进程。

管道是 Linux/Unix 中比较原始的通信方式，以数据流的方式在进程间流动。在 Linux 中，管道相当于一个文件，来缓存所要传输的数据。那管道和普通文件有什么区别呢？

- 管道是内核管理的一个固定大小的缓冲区
- 管道中的数据被读出来时，管道中就不存在数据了

#### 实现机制

在 Linux 中，管道的实现并没有借助特殊的数据结构，而是用了文件系统的 file 结构和虚拟文件系统 VFS 的索引结点 inode 来实现的。具体是将两个 file 结构指向同一个临时的 VFS 索引节点，再将这个 VFS 索引节点指向一个物理页面，从而实现管道的。


#### 特点

- 管道是半双工的，即数据只能向一个方向流动。可以通过建立两个管道来实现全双工
- 只能用于父子进程或者兄弟进程之间
- 可以理解为一种独立的文件系统，并且只存在于内存中
- 数据的流通方式是类似先进先出的队列

#### 创建

```C++
#include <unistd.h>
int pipe(int fd[2]) // 使用 pipe 函数创建一个匿名的半双工的管道
// fd[2] 为一个长度为 2 的文件描述数组，fd[0] 是读出端，fd[1] 是写入端，函数返回值为 0 表示成功，-1 表示失败
```

### 命名管道 FIFO

命名管道也被称为 FIFO 文件，在文件系统中以文件名的形式存在。也是半双工的，但允许无亲缘关系的进程之间进行通信。

#### 特点

- 提供一个文件路径，以 FIFO 的文件形式存在于文件系统中

#### 创建

```C++
#include <sys/types.h> 
#include <sys/stat.h> 
int mkfifo(const char *pathname, mode_t mode);
```

### 消息队列

Linux 中的消息可以被描述成在内核地址空间的一个内部链表，每一个消息队列由一个 IPC 的标识号唯一地标识。Linux 为系统中所有的消息队列维护一个 msgque 链表，该链表中的每个指针指向一个 msgid_ds 结构，该结构完整描述一个消息队列。

消息队列独立于进程而存在，为了区别不同的消息队列，需要以 key 值标记消息队列，这样两个不相关进程可以通过事先约定的 key 值通过消息队列进行消息收发。

#### 优势

- 可以自定义条件接收特定类型的消息
- 消息队列存放在内核中，只有在内核重启 (即操作系统重启) 或者显示地删除一个消息队列时，该消息队列才会被真正的删除
- 消息队列的发送和接受是相互独立的

### System V 共享内存

> 共享内存是最有用且最快的 IPC 方式。

所谓共享内存就是我们所理解的那样，同一块物理内存被映射到不同的进程地址空间上。不同的进程对共享内存中的数据进行修改可以被其他进程看到，但需要有同步机制或者互斥锁或者信号量进行约束。

#### 实现机制

- VFS/IO Buffer/Page Cache/文件读写
- mmap()
- 共享内存建立
    - shmget() 创建共享内存
    ```C+
    int shmget(key_t key, size_t size, int shmflg);
    ```
    - shmat() 启动对共享内存的访问
    ```C++
    void *shmat(int shm_id, const void *shm_addr, int shmflg);
    ```
    - 进程之间共享数据


#### 特点

- 共享内存中的数据，从来不会写到实际的磁盘文件中去，而是通过共享内存通信来指定何时将数据写入磁盘文件中
- 共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在
- 在该机制中，进程共享的真正内存是特殊文件系统 shm 中的同名文件

### mmap()

mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。

#### 实现过程

- 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域
- 调用内核空间的系统调用函数 mmap，实现文件物理地址和进程虚拟地址的一一映射关系
- 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存的拷贝

#### 函数原型

```C++
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

#### 使用 mmap 的目的

- 使用普通文件以提供内存映射 IO
- 使用特殊文件以提供匿名内存映射
- 使用 shm_open 以提供无亲缘关系的进程间的 Poxis 共享内存区

#### mmap 优势

- 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数
- 实现了用户空间和内核空间的高效交互方式
- 提供进程间共享内存以及相互通信的方式
- 可用于实现高效的大规模数据传输

### Socket

> 首选。

可以跨主机间通信，具有伸缩性。

## 线程间通信

线程同步的四项原则：

- 尽量最低限度地共享对象，减少需要同步的场合。即一个对象能不暴露给别的线程就不要暴露，一定要暴露的话，优先考虑immutable对象。最后实在不行，则用同步策略来获得充分的保护
- 使用高级的并发编程构件，如 TaskQueue，Producer-Consumer Queue，CountDownLatch等
- 最后不得已必需使用底层同步原语时，只用非递归的互斥器和条件变量，偶尔用一下读写锁
- 不要自己编写lock-free的代码

### 临界区

### 互斥器

我们可以用RAII的手法去封装mutex的创建、销毁、加锁和解锁操作。只用非递归的mutex，即不可重入的mutex。

### 信号量

### 事件

### 条件变量

条件变量又叫管程。

一个或多个线程等待某个布尔表达式为真，即等待别的线程”唤醒“它。

条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如BlockingQueue，CountDownLatch。

### 读写锁

分为读者和写者，读锁可重入，写锁不可重入。

## Ref

- [https://www.jianshu.com/p/758c7e0df40d](https://www.jianshu.com/p/758c7e0df40d)
- [https://www.jianshu.com/p/472ea35448ca](https://www.jianshu.com/p/472ea35448ca)
