# 网络相关

> 关于 TCP 的详解，可以看耗子叔的文章：[https://coolshell.cn/articles/11564.html](https://coolshell.cn/articles/11564.html) 和 [https://coolshell.cn/articles/11609.html](https://coolshell.cn/articles/11609.html).

## IP 地址，子网掩码和网络地址

已知 IP = 192.168.100.5，子网掩码 = 255.255.255.0，求网络地址。

```
// 将上述地址变换为二进制
                              |--------->网络地址<---------|->主机地址<-|
                              |                            |
192 168 100 5          ---->  | 11000000 10101000 01100100 |  00000101  |
255 255 255 0          ---->  | 11111111 11111111 11111111 |  00000000  |
            &          
-------------------------------------------------------------------------
192 168 100 0          ---->  | 11000000 10101000 01100100 |  00000000  |     <--------网络地址
192 168 100 255        ---->  | 11000000 10101000 01100100 |  11111111  |     <--------广播地址
网络范围               ---->  |     192 168 100 1 -- 192 168 100 254    |
主机数量               ---->  |             2^8 - 2 = 254               |

```


## 七/四层模型

七层：

- 物理层
- 数据链路层
- 网络层：IP，ICMP，ARP
- 运输层：TCP，UDP
- 会话层
- 表示层
- 应用层：HTTP，DNS

四层：

- 网络接口层
- 网络层
- 运输层
- 应用层

## 三次握手和四次挥手

三次握手即是 TCP 建立连接的过程，四次挥手即是 TCP 释放连接的过程。

三次握手的目的是为了消除旧有连接请求的 SYN 消息对新连接的干扰，同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。

四次挥手的目的是为了证服务器与客户端都能完全的接受对方发送的数据。

具体来说，假设 A 为客户端，B 为服务器。

三次握手就是说，B 处于监听状态，等待连接。然后 A -> B 发送连接请求，B -> A 发送应答，A -> B 发送确认，B 收到 A 发来的确认后建立连接。

四次挥手就是说，A -> B 发送释放连接报文，B -> A 发出确认，当 B 不再需要连接时，B -> A 发送连接释放报文，A 收到确认后，进入 TIME_WAIT 状态，等待 2 MSL 后，A -> B 发送释放连接，B 收到确认后释放连接。

其中，MSL 是指最大分节生命期，这是一个 IP 数据包能在互联网上生存的最长时间，超过这个时间 IP 数据包将在网络中消失 。

## 为什么不能只进行两次握手

三次握手的目的是为了消除旧有连接请求的 SYN 消息对新连接的干扰，同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。

如果只有两次握手，那么第二次握手后服务器只向客户端发送 ACK 包，此时客户端与服务器端建立连接，就会导致客户端和服务器之间无法知道是否收到应答。

## TCP 和 UDP 的区别

TCP 是一种面向连接的、可靠的、端到端的传输协议，而 UDP 则是面向无连接的不可靠传输协议。

## TCP 协议有几大计时器

- 重传定时器：希望收到另一端的确认。
- 坚持定时器：使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。
- 保活定时器：可检测到一个空闲连接的另一端何时崩溃或重启。
- 2MSL 定时器：测量一个连接处于 TIME_WAIT状态的时间。

## TCP 首部中的标识位

- URG：为1时，表示紧急指针有效
- ACK：确认标识，连接建立成功后，总为1。为1时确认号有效
- PSH：接收方应尽快把这个报文交给应用层
- RST：复位标识，重建连接
- SYN：建立新连接时，该位为0
- FIN：关闭连接标识

## HTTP 的连接过程

键入网址后，连接过程如下：

- 浏览器向 DNS 服务器请求解析输入的网址中的域名所对应的 IP 地址
- 解析出 IP 后，根据 IP 地址和默认端口 80 与服务器建立 TCP 连接
- 浏览器发送读取文件的 HTTP 请求，作为 TCP 三次握手的第三个报文数据发送给服务器
- 服务器对浏览器的请求作出响应，并把对应的 HTML 文本发送给浏览器
- 释放 TCP 连接
- 浏览器接收 HTML 文本并显示文本内容

## HTTPS 和 HTTP 的区别

### HTTP 的原理

HTTP 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

具体原理如下：

- 客户端连接到 Web 服务器
- 发送 HTTP 请求
- 服务器接受请求并返回 HTTP 响应
- 释放 TCP 连接
- 客户端浏览器解析 HTML 内容

### HTTPS 的原理

HTTPS 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即在 HTTP 下加入了 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

HTTPS 协议的主要作用：

- 建立一个信息安全通道，来保证数据传输的安全
- 确认网站的真实性

具体原理如下：

- 客户端发起 HTTPS 请求
- 服务端进行配置
- 传送证书
- 客户端解析证书
- 传送加密信息
- 服务端解密信息
- 传输加密后的信息
- 客户端解密信息

### 二者的区别

- HTTP 协议传输的数据都是未加密的，不安全，而 HTTPS 是安全的；
- HTTPS 协议需要到 CA 申请证书，需要一定费用；
- 二者使用的连接方式不同，端口也不同，HTTP 是 80，HTTPS 是 443；
- HTTP 是一种无状态的连接。

## HTTP 1.0，1.1 和 2.0 的区别

### 1.0 与 1.1 的区别

- 长连接：1.0 中需要使用 keep-alive 参数来告知服务端要建立一个长连接，而 1.1 中默认支持
- 带宽优化：1.1 比 1.0 更节约带宽
- 缓存处理：1.1 比 1.0 具有更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等
- 错误通知管理：1.1 中新增了 24 个错误状态响应码
- Host 头的处理：1.1 中支持 Host 头域

### 1.1 与 2.0 的区别

- 多路复用：2.0 中支持多路复用技术，且并发请求量远大于 1.1
- 数据压缩：2.0 中支持对 header 的数据进行压缩
- 服务器推送：2.0 中支持服务器推送功能

## 常用的请求方式

- GET       请求获取 Request-URI 所标识的资源
- POST      在 Request-URI 所标识的资源后附加新的数据
- HEAD      请求获取由 Request-URI 所标识的资源的响应消息报头
- PUT       请求服务器存储一个资源，并用 Request-URI 作为其标识
- DELETE    请求服务器删除 Request-URI 所标识的资源
- TRACE     请求服务器回送收到的请求信息，主要用于测试或诊断
- CONNECT   保留将来使用
- OPTIONS   请求查询服务器的性能，或者查询与资源相关的选项和需求

## GET 和 POST 的区别

- GET 提交的数据会在地址栏中显示出来，而 POST 不会
- GET 提交的数据有大小限制，而 POST 没有
- GET 的安全性不如 POST 的安全性好
- 二者获取变量的值的方式不同，GET 使用 Request.QueryString，POST 使用 Request.Form

## 长连接和短连接的区别

> 长连接是指的 TCP 连接，而不是 HTTP 连接。

- 短连接：连接 -> 传输数据 -> 关闭连接
- 长连接：连接 -> 传输数据 -> 保持连接 -> 传输数据 -> ... -> 关闭连接

长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，而类似 Web 网站的 http 服务都用短连接。

### 主要区别

- 二者的决定方式不同
    - 一个 TCP 连接是哪一种连接，需要 HTTP 的 Connection Header 来决定的
    - 而一种轮询方式是哪一种连接，需要根据服务端的处理方式来决定的，与客户端没关系
- 二者的实现方式不同
    - 一个是通过洗衣来规定和实现的
    - 一个是服务器通过编程的方式手动刮起请求来实现的

## 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此需要进行适当的控制，而拥塞控制主要是为了降低整个网络的拥塞程度。

TCP 中有四个算法可以用来控制拥塞，分别是慢开始，拥塞避免，快重传，快恢复。

慢开始就是说在执行的最开始，发送方发送的报文很少，只能是 1 个，收到确认后再加倍。

通过设置一个慢开始门限，使得发送报文的数量大于等于门限值的时候，就进入拥塞避免。

快重传就是说在接收到三个重复确认后，便可以确定下一个报文段丢失，则立即重传下一个报文段。

快恢复则是将发送的报文数量设置为门限值，当丢失个别报文段的时候执行快恢复。

## TCP 的拆包和粘包

### 粘包

粘包问题的最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪。

产生粘包问题的原因：

- 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上

如何解决：

- 使用定长消息
- 设置消息边界
- 使用结构体，显式说明数据部分的长度
- 按行读取

### 拆包

产生拆包的原因：

- 应用程序写入的数据大于套接字缓冲区大小

## 流量控制

流量控制是为了控制发送方的发送速率，以保证接收方来得及接收。

## 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态; 接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

## TIME_WAIT 状态

在通信双方建立 TCP 连接后，主动关闭连接的一方就会进入 TIME_WAIT 状态，主要是客户端会进入该状态，并且会占用端口。

该状态不可避免，也是 TCP 的本身设计如此。主要因为：

- 可靠地实现了 TCP 全双工连接的终止
- 保证让迟来的 TCP 报文段有足够的时间被识别并丢弃

TIME_WAIT 状态维持时间是两个 MSL 时间的长度，也就是在 1-4 分钟，Windows 操作系统就是 4 分钟。

那如何避免呢？

客户端可以通过选用临时端口来避免该状态。服务端可以通过使用 socket 中的 SO_REUSEADDR 选项来强制使用处于 TIME_WAIT 状态的连接占用的端口。

当然也可以修改内核参数来使得 TCP 根本无法进入该状态。

## WebSocket 协议

Webscoket 是 Web 浏览器和服务器之间的一种全双工通信协议。

可是为什么还要有 WebSocket 协议呢？因为 HTTP 协议有一个缺陷：通信只能由客户端发起。

### 与 HTTP 协议的区别

- 都是基于 TCP 的应用层协议；
- 都使用 Request/Response 模型进行连接的建立；
- 都可以在网络中传输数据；
- WS 使用 HTTP 来建立连接；
- WS 的连接不能通过中间人来转发，它必须是一个直接连接；
- WS 的数据帧有序。

### 特点

- 主动推送功能：服务器可以直接向客户端推送消息，当然客户端也可以主动向服务器发送信息；
- 减少通信量：只要第一次建立连接，就可以一直进行通信。而不是 HTTP 协议的一问一答模式。

### 心跳检测

心跳检测是用来检测客户端和服务端是否处于正常连接状态的一种检测机制。

## TCP 的可靠传输如何实现的

- 分块传送
- 等待确认
- 超时重传：即一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。
- 确认信号
- 校验和
- 重新排序
- 丢弃重复
- 流量控制

## 如何实现一个可靠的 UDP

最简单的方式是在应用层模仿传输层 TCP 的可靠性传输，不考虑拥塞处理。

- 添加 seq/ack 机制，即应答确认，确保数据发送到对端；
- 添加发送和接收缓冲区；
- 添加超时重传机制；
- 添加包序号，保证报文的有序接收；
- 添加滑动窗口机制；
- 添加流量控制机制。

一些已有的项目实现了可靠的 UDP 协议，如 RUDP(Reliable User Datagram Protocol)，RTP(Real Time Protocol)，UDT(UDP-based Data Transfer Protocol) 等。

## 攻击技术

- DDoS
- XSS
- CSRF
- SQL Injection

## Ref

- [https://huoding.com/2013/12/31/316](https://huoding.com/2013/12/31/316)
- [https://juejin.im/post/5ba895a06fb9a05ce95c5dac](https://juejin.im/post/5ba895a06fb9a05ce95c5dac)
- [http://www.ruanyifeng.com/blog/2017/05/websocket.html](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
- [https://juejin.im/entry/58d7635e5c497d0057fae036](https://juejin.im/entry/58d7635e5c497d0057fae036)
- [http://www.ruanyifeng.com/blog/2016/08/http.html](http://www.ruanyifeng.com/blog/2016/08/http.html)
- [https://developer.mozilla.org/zh-CN/docs/Web/HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)
- [https://blog.csdn.net/linsongbin1/article/details/54980801](https://blog.csdn.net/linsongbin1/article/details/54980801)
