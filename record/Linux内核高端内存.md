# Linux 内核高端内存

我们知道，当内核代码或者线程访问内存时，代码中的内存地址都是逻辑地址，需要有一个映射才能对应到真正的物理地址。通常，逻辑地址与物理地址的对应关系为：物理地址 = 逻辑地址 - 0xC0000000。但我们可以发现一个问题，通常情况下逻辑地址对应的物理地址仅能访问1G 的物理内存，显然对于大内存的机器很浪费，但也的的确确无法继续访问某个物理地址之后的内存了。

此时，便出现了高端内存的概念。为了访问其他的内存地址，我们就不能简单的将逻辑地址映射为物理地址。因此，在 x86 架构中将内核地址空间划分为三个部分，即ZONE_DMA, ZONE_NORMAL和ZONE_HIGHMEM。其中，ZONE_HIGHMEM 即为高端内存，其地址空间范围为0xF8000000 ~ 0xFFFFFFFF，即896MB～1024MB。如下图所示：

![](#./pics/highmem.png)

那高端内存是如何通过128MB的高端内存访问其他物理内存呢？

当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。

例如内核想访问2G开始的一段大小为1MB的物理内存，即物理地址范围为0x80000000 ~ 0x800FFFFF。访问之前先找到一段1MB大小的空闲地址空间，假设找到的空闲地址空间为0xF8700000 ~ 0xF87FFFFF，用这1MB的逻辑地址空间映射到物理地址空间0x80000000 ~ 0x800FFFFF的内存。当内核访问完0x80000000 ~ 0x800FFFFF物理内存后，就将0xF8700000 ~ 0xF87FFFFF内核线性空间释放。这样其他进程或代码也可以使用0xF8700000 ~ 0xF87FFFFF这段地址访问其他物理内存。

因此，我们可以了解到 Linux 的高端内存的基本思想是这样的：借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。

其他的内容大家可以参考下面的两个链接。


## Ref

- [http://ilinuxkernel.com/?p=1013](http://ilinuxkernel.com/?p=1013)
- [https://cloud.tencent.com/developer/article/1374639](https://cloud.tencent.com/developer/article/1374639)

