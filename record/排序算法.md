# 排序算法

今天来总结下各种排序算法的思想吧，尽管是很基础的东西，但是还是会忘却。

具体可参考[这里](https://github.com/ZXZxin/ZXBlog/blob/master/数据结构算法/Algorithm/Sort/各种排序算法总结(全面).md)和[这里](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg).

## 冒泡排序

从后往前，两两交换，小的在前。该算法的时间复杂度 O(n)，最坏和平均都是O(n^2).

所以有种改进的冒泡排序算法：鸡尾酒排序，即从两端同时进行冒泡。

代码见[这里](https://github.com/i0Ek3/awesome-architect/blob/master/example/cocktailsort.cpp).

## 选择排序

从序列中找出最大或者最小的值，放到序列的起始位置，作为已排序的序列。再从剩余的序列中找出最大或者最小的值，插入到已排序序列的末尾，以此往复。

代码见[这里](https://github.com/i0Ek3/awesome-architect/blob/master/example/selectsort.cpp).

## 插入排序

## 二分插入排序

## 希尔排序

## 快速排序

先找到一个基准，然后设定两个指针，一个指向基准后面的元素，一个指向最后一个元素。从后往前开始，依次和基准进行比较，小则交换两个指针指向位置的元素，否则向前或者向后移动两个指针。

就是一个递归的过程，将原序列一分为二，分别递归。

但是普通快速排序存在一些问题，所以我们需要优化一下原始的算法。

- 随机快排，解决基准不好选的问题。原本的快排在选取基准时可能过大或者过小，导致后面划分的数组不平衡，使得时间复杂度降为O(n^2)，而随机快排会随机选取一个基准点，而不是将a[left]作为划分点。
- 双路快排，解决重复元素多的问题。如果排序的数组重复元素过多，仍然会使得划分不均匀。这里换一种划分方式，将小等于key和大等于key的元素分别放在数组的两边。两个指针分别指向left和right，然后向中间靠拢，分别找到第一个大等于key和小等于key的值时，停止扫描，交换之。两个指针相遇则终止。
- 三路快排，更好的解决重复元素的问题，其关键在于对对partition的划分。这里将序列划分为三个部分，大于key的在右边，小于key的在左边，等于key的在中间。再对左右区间重复三路划分，直到各个区间只有一个数为止。

代码见[这里](https://github.com/i0Ek3/awesome-architect/blob/master/example/qsort.cpp).

## 归并排序

将序列划分为几个区间，各区间内分别排序。归并排序有多种，如二路归并，三路归并等。

## 堆排序

## 桶排序

桶排序的思想在于先确定元素值所在的区间，也就是分成几个桶，将元素放到这些桶中，然后对桶里面的元素进行排序。

## 基数排序

基数排序就是基于一个数的各个位数进行大小排序，先从个位然后十位这样。

## 计数排序


